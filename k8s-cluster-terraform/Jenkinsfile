pipeline {
    agent any
    
    environment {
        GOOGLE_APPLICATION_CREDENTIALS = credentials('gcp-service-account')
        TF_VAR_project_id = 'beaming-pillar-461818-j7'
        TF_IN_AUTOMATION = 'true'
        TF_INPUT = 'false'
        PATH = "${env.PATH}:/opt/homebrew/bin"
    }
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['prod', 'stage'],
            description: 'Select environment to deploy (prod or stage)'
        )
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Select Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto approve Terraform apply/destroy (use with caution in production)'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.BUILD_TIMESTAMP = sh(
                        script: 'date +"%Y%m%d-%H%M%S"',
                        returnStdout: true
                    ).trim()
                    
                    // Set environment-specific variables
                    env.TF_WORKSPACE_DIR = "k8s-cluster-terraform/${params.ENVIRONMENT}"
                    env.CLUSTER_NAME = "k8s-cluster-${params.ENVIRONMENT}"
                    env.NETWORK_NAME = "gke-network-${params.ENVIRONMENT}"
                    
                    echo "üöÄ Deploying to: ${params.ENVIRONMENT}"
                    echo "üìÅ Working directory: ${env.TF_WORKSPACE_DIR}"
                    echo "üéØ Cluster name: ${env.CLUSTER_NAME}"
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    sh '''
                        echo "Setting up environment for ${ENVIRONMENT}..."
                        
                        # Verificar herramientas
                        gcloud version
                        terraform version
                        
                        # Autenticar con Google Cloud
                        gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS
                        gcloud config set project $TF_VAR_project_id
                        
                        # Verificar autenticaci√≥n b√°sica
                        gcloud auth list
                        
                        echo "‚úÖ Environment setup complete for ${ENVIRONMENT}"
                    '''
                }
            }
        }
        
        stage('Terraform Init') {
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        sh '''
                            echo "Current directory: $(pwd)"
                            echo "Initializing Terraform for ${ENVIRONMENT} environment..."
                            
                            if ! terraform init; then
                                echo "Standard init failed, trying with upgrade..."
                                rm -rf .terraform .terraform.lock.hcl
                                terraform init -upgrade
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Validate') {
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    sh '''
                        echo "Validating Terraform configuration for ${ENVIRONMENT}..."
                        terraform validate
                    '''
                }
            }
        }
        
        stage('Check for State Conflicts') {
            when {
                anyOf {
                    expression { params.ACTION == 'plan' }
                    expression { params.ACTION == 'apply' }
                }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        sh '''
                            echo "üîç Checking for potential state conflicts in ${ENVIRONMENT}..."
                            
                            # Verificar si hay node pools existentes en GCP
                            echo "Checking existing node pools in GCP for ${CLUSTER_NAME}..."
                            gcloud container node-pools list \
                                --cluster=${CLUSTER_NAME} \
                                --region=us-central1 \
                                --project=$TF_VAR_project_id \
                                --format="value(name)" || echo "No existing node pools or cluster not found"
                            
                            # Verificar estado de Terraform
                            echo "Checking Terraform state..."
                            terraform state list | grep node_pool || echo "No node pools in Terraform state"
                            
                            echo "‚úÖ State conflict check completed for ${ENVIRONMENT}"
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Plan') {
            when {
                anyOf {
                    expression { params.ACTION == 'plan' }
                    expression { params.ACTION == 'apply' }
                }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        def planExitCode = sh(
                            script: '''
                                echo "Creating Terraform plan for ${ENVIRONMENT}..."
                                terraform plan \
                                    -var="project_id=$TF_VAR_project_id" \
                                    -out=tfplan-${ENVIRONMENT}-${BUILD_TIMESTAMP} \
                                    -detailed-exitcode
                            ''',
                            returnStatus: true
                        )
                        
                        // Handle Terraform plan exit codes
                        if (planExitCode == 0) {
                            echo "‚úÖ No changes needed for ${params.ENVIRONMENT}"
                        } else if (planExitCode == 2) {
                            echo "‚úÖ Changes detected and planned successfully for ${params.ENVIRONMENT}"
                        } else {
                            error "‚ùå Terraform plan failed for ${params.ENVIRONMENT} with exit code: ${planExitCode}"
                        }
                        
                        // Archive the plan file
                        archiveArtifacts artifacts: "tfplan-${params.ENVIRONMENT}-${env.BUILD_TIMESTAMP}", 
                                       allowEmptyArchive: false
                    }
                }
            }
        }
        
        stage('Terraform Apply') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        if (params.AUTO_APPROVE) {
                            sh '''
                                echo "Applying Terraform changes for ${ENVIRONMENT} with auto-approve..."
                                terraform apply -auto-approve tfplan-${ENVIRONMENT}-${BUILD_TIMESTAMP}
                            '''
                        } else {
                            timeout(time: 10, unit: 'MINUTES') {
                                input message: "Approve Terraform Apply for ${params.ENVIRONMENT}?", 
                                      ok: 'Apply',
                                      submitterParameter: 'APPROVER'
                            }
                            sh '''
                                echo "Applying Terraform changes for ${ENVIRONMENT}..."
                                terraform apply tfplan-${ENVIRONMENT}-${BUILD_TIMESTAMP}
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Terraform Destroy Plan') {
            when {
                expression { params.ACTION == 'destroy' }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        def destroyPlanExitCode = sh(
                            script: '''
                                echo "Creating Terraform destroy plan for ${ENVIRONMENT}..."
                                terraform plan -destroy \
                                    -var="project_id=$TF_VAR_project_id" \
                                    -out=destroy-plan-${ENVIRONMENT}-${BUILD_TIMESTAMP} \
                                    -detailed-exitcode
                            ''',
                            returnStatus: true
                        )
                        
                        // Handle Terraform destroy plan exit codes
                        if (destroyPlanExitCode == 0) {
                            echo "‚úÖ No resources to destroy in ${params.ENVIRONMENT}"
                        } else if (destroyPlanExitCode == 2) {
                            echo "‚úÖ Destroy plan created successfully for ${params.ENVIRONMENT}"
                        } else {
                            error "‚ùå Terraform destroy plan failed for ${params.ENVIRONMENT} with exit code: ${destroyPlanExitCode}"
                        }
                        
                        // Archive the destroy plan
                        archiveArtifacts artifacts: "destroy-plan-${params.ENVIRONMENT}-${env.BUILD_TIMESTAMP}", 
                                       allowEmptyArchive: false
                    }
                }
            }
        }
        
        stage('Terraform Destroy') {
            when {
                expression { params.ACTION == 'destroy' }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        if (params.AUTO_APPROVE) {
                            sh '''
                                echo "Destroying infrastructure for ${ENVIRONMENT} with auto-approve..."
                                terraform apply -auto-approve destroy-plan-${ENVIRONMENT}-${BUILD_TIMESTAMP}
                            '''
                        } else {
                            timeout(time: 10, unit: 'MINUTES') {
                                input message: "Approve Terraform Destroy for ${params.ENVIRONMENT}? This will DELETE all infrastructure!", 
                                      ok: 'Destroy',
                                      submitterParameter: 'APPROVER'
                            }
                            sh '''
                                echo "Destroying infrastructure for ${ENVIRONMENT}..."
                                terraform apply destroy-plan-${ENVIRONMENT}-${BUILD_TIMESTAMP}
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Generate Kubeconfig') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        sh '''
                            echo "Checking for kubeconfig for ${ENVIRONMENT}..."
                            if [ -f kubeconfig-${ENVIRONMENT} ]; then
                                echo "Kubeconfig generated successfully for ${ENVIRONMENT}"
                                
                                # Test cluster connectivity (opcional)
                                export KUBECONFIG=./kubeconfig-${ENVIRONMENT}
                                kubectl cluster-info --request-timeout=30s || echo "Cluster not ready yet, but kubeconfig exists"
                            else
                                echo "Warning: kubeconfig-${ENVIRONMENT} not found"
                            fi
                        '''
                        
                        // Archive kubeconfig if it exists
                        archiveArtifacts artifacts: "kubeconfig-${params.ENVIRONMENT}", 
                                       allowEmptyArchive: true
                    }
                }
            }
        }
        
        stage('Terraform Output') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                dir("${env.TF_WORKSPACE_DIR}") {
                    script {
                        sh '''
                            echo "=== Terraform Outputs for ${ENVIRONMENT} ==="
                            terraform output || echo "No outputs available"
                        '''
                    }
                }
            }
        }
        
        stage('Deploy ELK Stack') {
            when {
                allOf {
                    expression { params.ACTION == 'apply' }
                    expression { params.ENVIRONMENT == 'prod' } // Only deploy ELK in production
                }
            }
            steps {
                script {
                    sh '''
                        echo "üîç Checking ELK Stack deployment status for ${ENVIRONMENT}..."
                        
                        # Set kubeconfig
                        export KUBECONFIG=${TF_WORKSPACE_DIR}/kubeconfig-${ENVIRONMENT}
                        
                        # Verify cluster connectivity
                        kubectl cluster-info --request-timeout=30s
                        
                        # Function to check if a Helm release exists and is deployed
                        check_helm_release() {
                            local release_name=$1
                            local namespace=$2
                            
                            if /opt/homebrew/bin/helm list -n $namespace | grep -q "^$release_name\\s"; then
                                local status=$(/opt/homebrew/bin/helm list -n $namespace | grep "^$release_name\\s" | awk '{print $8}')
                                if [ "$status" = "deployed" ]; then
                                    echo "‚úÖ $release_name is already deployed and running"
                                    return 0
                                else
                                    echo "‚ö†Ô∏è  $release_name exists but status is: $status"
                                    return 1
                                fi
                            else
                                echo "‚ùå $release_name is not deployed"
                                return 1
                            fi
                        }
                        
                        # Function to check if pods are running
                        check_pods_running() {
                            local app_label=$1
                            local namespace=$2
                            local min_pods=${3:-1}
                            
                            local running_pods=$(kubectl get pods -n $namespace -l app=$app_label --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                            if [ "$running_pods" -ge "$min_pods" ]; then
                                echo "‚úÖ $app_label has $running_pods running pods"
                                return 0
                            else
                                echo "‚ùå $app_label has only $running_pods running pods (minimum: $min_pods)"
                                return 1
                            fi
                        }
                        
                        # Create namespace for ELK if it doesn't exist
                        kubectl create namespace elk || echo "Namespace elk already exists"
                        
                        # Add Elastic Helm repository
                        /opt/homebrew/bin/helm repo add elastic https://helm.elastic.co
                        /opt/homebrew/bin/helm repo update
                        
                        # Check each component
                        ELASTICSEARCH_DEPLOYED=false
                        KIBANA_DEPLOYED=false
                        LOGSTASH_DEPLOYED=false
                        FILEBEAT_DEPLOYED=false
                        
                        echo "üîç Checking Elasticsearch..."
                        if check_helm_release "elasticsearch" "elk" && check_pods_running "elasticsearch-master" "elk" 1; then
                            ELASTICSEARCH_DEPLOYED=true
                        fi
                        
                        echo "üîç Checking Kibana..."
                        if check_helm_release "kibana" "elk" && check_pods_running "kibana" "elk" 1; then
                            KIBANA_DEPLOYED=true
                        fi
                        
                        echo "üîç Checking Logstash..."
                        if check_helm_release "logstash" "elk" && check_pods_running "logstash" "elk" 1; then
                            LOGSTASH_DEPLOYED=true
                        fi
                        
                        echo "üîç Checking Filebeat..."
                        if check_helm_release "filebeat" "elk" && check_pods_running "filebeat" "elk" 1; then
                            FILEBEAT_DEPLOYED=true
                        fi
                        
                        # Deploy only missing components
                        if [ "$ELASTICSEARCH_DEPLOYED" = "false" ]; then
                            echo "üìä Installing/Upgrading Elasticsearch..."
                            /opt/homebrew/bin/helm upgrade --install elasticsearch elastic/elasticsearch \\
                                --namespace elk \\
                                --values elk/elasticsearch-values.yaml \\
                                --wait --timeout=10m
                        else
                            echo "‚è≠Ô∏è  Elasticsearch already deployed, skipping..."
                        fi
                        
                        if [ "$KIBANA_DEPLOYED" = "false" ]; then
                            echo "üìà Installing/Upgrading Kibana..."
                            /opt/homebrew/bin/helm upgrade --install kibana elastic/kibana \\
                                --namespace elk \\
                                --values elk/kibana-values.yaml \\
                                --wait --timeout=10m
                        else
                            echo "‚è≠Ô∏è  Kibana already deployed, skipping..."
                        fi
                        
                        if [ "$LOGSTASH_DEPLOYED" = "false" ]; then
                            echo "üîÑ Installing/Upgrading Logstash..."
                            /opt/homebrew/bin/helm upgrade --install logstash elastic/logstash \\
                                --namespace elk \\
                                --values elk/logstash-values.yaml \\
                                --wait --timeout=10m
                        else
                            echo "‚è≠Ô∏è  Logstash already deployed, skipping..."
                        fi
                        
                        if [ "$FILEBEAT_DEPLOYED" = "false" ]; then
                            echo "üìã Installing/Upgrading Filebeat..."
                            /opt/homebrew/bin/helm upgrade --install filebeat elastic/filebeat \\
                                --namespace elk \\
                                --values elk/filebeat-values.yaml \\
                                --wait --timeout=10m
                        else
                            echo "‚è≠Ô∏è  Filebeat already deployed, skipping..."
                        fi
                        
                        echo "‚úÖ ELK Stack validation and deployment completed!"
                        
                        echo "üìã Final ELK Stack Status:"
                        kubectl get pods -n elk
                        kubectl get services -n elk
                        
                        echo ""
                        echo "üîó To access Kibana, run the following command after the pipeline:"
                        echo "kubectl port-forward -n elk service/kibana-kibana 5601:5601"
                        echo "Then open: http://localhost:5601"
                    '''
                }
            }
        }
        
        stage('Deploy Prometheus & Grafana') {
            when {
                allOf {
                    expression { params.ACTION == 'apply' }
                    expression { params.ENVIRONMENT == 'prod' } // Only deploy Prometheus & Grafana in production
                }
            }
            steps {
                script {
                    sh '''
                        echo "üîç Checking Prometheus & Grafana deployment status for ${ENVIRONMENT}..."
                        
                        # Set kubeconfig
                        export KUBECONFIG=${TF_WORKSPACE_DIR}/kubeconfig-${ENVIRONMENT}
                        
                        # Verify cluster connectivity
                        kubectl cluster-info --request-timeout=30s
                        
                        # Function to check if a Helm release exists and is deployed
                        check_helm_release() {
                            local release_name=$1
                            local namespace=$2
                            
                            if /opt/homebrew/bin/helm list -n $namespace | grep -q "^$release_name\\s"; then
                                local status=$(/opt/homebrew/bin/helm list -n $namespace | grep "^$release_name\\s" | awk '{print $8}')
                                if [ "$status" = "deployed" ]; then
                                    echo "‚úÖ $release_name is already deployed and running"
                                    return 0
                                else
                                    echo "‚ö†Ô∏è  $release_name exists but status is: $status"
                                    return 1
                                fi
                            else
                                echo "‚ùå $release_name is not deployed"
                                return 1
                            fi
                        }
                        
                        # Function to check if pods are running
                        check_pods_running() {
                            local app_label=$1
                            local namespace=$2
                            local min_pods=${3:-1}
                            
                            local running_pods=$(kubectl get pods -n $namespace -l app.kubernetes.io/name=$app_label --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                            if [ "$running_pods" -ge "$min_pods" ]; then
                                echo "‚úÖ $app_label has $running_pods running pods"
                                return 0
                            else
                                echo "‚ùå $app_label has only $running_pods running pods (minimum: $min_pods)"
                                return 1
                            fi
                        }
                        
                        # Create namespace for monitoring if it doesn't exist
                        kubectl create namespace monitoring || echo "Namespace monitoring already exists"
                        
                        # Step 1: Add Prometheus Helm repository (following the blog)
                        echo "üì¶ Adding Prometheus community Helm repository..."
                        /opt/homebrew/bin/helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                        /opt/homebrew/bin/helm repo update
                        
                        # Step 2: Add Grafana Helm repository (following the blog)
                        echo "üì¶ Adding Grafana Helm repository..."
                        /opt/homebrew/bin/helm repo add grafana https://grafana.github.io/helm-charts
                        /opt/homebrew/bin/helm repo update
                        
                        # Check Prometheus deployment status
                        PROMETHEUS_DEPLOYED=false
                        GRAFANA_DEPLOYED=false
                        
                        echo "üîç Checking Prometheus..."
                        if check_helm_release "prometheus" "monitoring" && check_pods_running "prometheus" "monitoring" 1; then
                            PROMETHEUS_DEPLOYED=true
                        fi
                        
                        echo "üîç Checking Grafana..."
                        if check_helm_release "grafana" "monitoring" && check_pods_running "grafana" "monitoring" 1; then
                            GRAFANA_DEPLOYED=true
                        fi
                        
                        # Step 3: Install Prometheus (following the blog exactly)
                        if [ "$PROMETHEUS_DEPLOYED" = "false" ]; then
                            echo "üìä Installing Prometheus using Helm for ${ENVIRONMENT}..."
                            /opt/homebrew/bin/helm install prometheus prometheus-community/prometheus \\
                                --namespace monitoring \\
                                --wait --timeout=10m
                            
                            echo "üåê Exposing Prometheus server service as NodePort..."
                            kubectl expose service prometheus-server \\
                                --type=NodePort \\
                                --target-port=9090 \\
                                --name=prometheus-server-ext \\
                                --namespace monitoring || echo "Service already exposed"
                        else
                            echo "‚è≠Ô∏è  Prometheus already deployed, skipping..."
                        fi
                        
                        # Step 4: Install Grafana (following the blog exactly)
                        if [ "$GRAFANA_DEPLOYED" = "false" ]; then
                            echo "üìà Installing Grafana using Helm for ${ENVIRONMENT}..."
                            /opt/homebrew/bin/helm install grafana grafana/grafana \\
                                --namespace monitoring \\
                                --wait --timeout=10m
                            
                            echo "üåê Exposing Grafana service as NodePort..."
                            kubectl expose service grafana \\
                                --type=NodePort \\
                                --target-port=3000 \\
                                --name=grafana-ext \\
                                --namespace monitoring || echo "Service already exposed"
                        else
                            echo "‚è≠Ô∏è  Grafana already deployed, skipping..."
                        fi
                        
                        echo "‚úÖ Prometheus & Grafana validation and deployment completed for ${ENVIRONMENT}!"
                        
                        echo "üìã Final Monitoring Stack Status:"
                        kubectl get pods -n monitoring
                        kubectl get services -n monitoring
                        
                        echo ""
                        echo "üîó Access Information for ${ENVIRONMENT}:"
                        echo "üìä Prometheus: kubectl port-forward -n monitoring service/prometheus-server-ext 9090:9090"
                        echo "   Then open: http://localhost:9090"
                        echo ""
                        echo "üìà Grafana: kubectl port-forward -n monitoring service/grafana-ext 3000:3000"
                        echo "   Then open: http://localhost:3000"
                        echo ""
                        echo "üîë Get Grafana admin password:"
                        echo "   kubectl get secret --namespace monitoring grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo"
                        echo "   Username: admin"
                        echo ""
                        echo "üéØ Prometheus Data Source URL for Grafana:"
                        echo "   http://prometheus-server.monitoring.svc.cluster.local"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            // Clean up plan files
            dir("${env.TF_WORKSPACE_DIR}") {
                sh '''
                    echo "Cleaning up temporary files for ${ENVIRONMENT}..."
                    rm -f tfplan-* destroy-plan-*
                '''
            }
        }
        success {
            script {
                def message = """
                ‚úÖ **Terraform ${params.ACTION} completed successfully**
                
                **Build Details:**
                - Job: ${env.JOB_NAME}
                - Build: #${env.BUILD_NUMBER}
                - Environment: ${params.ENVIRONMENT}
                - Action: ${params.ACTION}
                - Project: ${env.TF_VAR_project_id}
                - Timestamp: ${env.BUILD_TIMESTAMP}
                """
                
                echo message
            }
        }
        failure {
            script {
                def message = """
                ‚ùå **Terraform ${params.ACTION} failed**
                
                **Build Details:**
                - Job: ${env.JOB_NAME}
                - Build: #${env.BUILD_NUMBER}
                - Environment: ${params.ENVIRONMENT}
                - Action: ${params.ACTION}
                - Project: ${env.TF_VAR_project_id}
                - Console: ${env.BUILD_URL}console
                """
                
                echo message
            }
        }
    }
}